# ===============================================================第一章 初识对象====================================================================


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 初识对象


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 成员方法
"""
# 类的定义和使用语法
class 类名称:   #class关键字, 表示要定义类
    类的属性    # 类的属性, 即定义在类中的变量(成员变量)
    类的行为    # 类的行为, 即定义在类中的函数(成员方法)
创建类对象的语法:
对象 = 类名称()

# 成员方法的使用
在类中定义成员方法和定义函数基本一致, 但仍有细微区别:
def 方法名(self, 形参1, ······, 形参N):
    方法体

# self关键字的作用
方法定义的参数列表中, 有一个self关键字, self关键字必须填写
    它用来表示类对象自身
    当我们使用类对象调用方法时, self会自动被python传入(自己传参时可以当它不存在)
    在方法内部, 想要访问类的成员变量, 必须使用self
"""
# 创建类
class Student:
    name = None
    gender = None
    nationality = None
    nation_place = None
    age = None

    def say_hi(self):
        print(f"大家好, 我是{self.name}")# 在方法内部, 想要访问类的成员变量, 必须使用self

    def say_hi2(self, msg):
        print(f"大家好, 我是{msg}")

# 创建对象
stu1 = Student()

# 对象属性赋值
stu1.name = "zhangsan"
stu1.gender= "male"
stu1.nationality = "china"
stu1.nation_place = "shandong"
stu1.age = 20

# 获取对象信息
print(stu1.age)
print(stu1.gender)
print(stu1.nation_place)
print(stu1.name)
print(stu1.nationality)

# 调用成员方法
stu1.say_hi()# 不给name的时候调用这个函数会输出大家好, 我是None   self参数可以当它不存在
stu1.say_hi2(f"宇宙超级无敌狂拽酷帅{stu1.name}")# 同样在调用时不用输入self


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 类和对象
"""
# 使用类描述现实世界事物的思想
现实世界的特征总体可以归纳为两类, 属性和行为
现实世界的事物分为事和物两类, 分别从属性和行为的角度来分析一下它们
比如做核酸和打扫卫生是事, 手机和狗狗是物
做核酸的属性包括何时、何地、谁, 行为包括登记、检测、查验结果
打扫卫生的属性是何时、何地、谁, 行为包括扫地、拖地、擦桌子等
手机的属性包括品牌、型号、重量、芯片种类等等, 行为包括打电话、上网、拍照等等
狗狗的属性包括名字、性别、品种、颜色、年龄等等, 行为包括汪汪叫、吃东西、睡觉等等
综上: 类可以描述现实世界中的所有事物

# 类和对象的关系
# 理解什么是面向对象
类可以理解为图纸, 基于图纸生产实体(对象), 才能正常工作, 这种设计思想或者说套路, 就被称为: 面向对象编程
"""
# 闹钟类举例
# 设计闹钟类
class Clock():
    id = None
    price = None

    def ring(self):
        import winsound
        winsound.Beep(2000, 3000)
# 构建闹钟对象并让其工作
clock = Clock()
clock.id = "006003"
clock.price = 8.7
print(f"闹钟ID{clock.id}, 它的价格是{clock.price}")
# clock.ring()# 不让它每次都响就注释掉了


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 构造方法
"""
# 使用构造方法向成员变量赋值
在前面几个小节给成员变量赋值的过程略显繁琐, 每个都逐一赋值, 构造方法给成员变量赋值, 让赋值过程更高效
思考: 类名称Student(), 这个()能否像函数(方法)那样, 通过传参的形式对其属性赋值呢
python类可以使用__init__()方法, 称为构造方法
可以实现:
    在创建类对象(构造类)的时候, 会自动执行(不调用也会自动执行)
    在创建类对象(构造类)的时候, 将传入参数自动传递给__init__方法使用
    有__init__方法, 类定义中的声明可以不写, 会在__init__方法里自动声明且赋值

练习:
请设计一个类, 记录学生的: 姓名、年龄、地址
请实现:
    通过for循环, 配合input输入语句, 并使用构造方法, 完成学生信息的键盘录入
    输入完成后, 使用print语句, 完成信息的输出
"""
# 创建类
class Student:
    name = None
    gender = None
    age = None
    # 有__init__方法, 上面的三行声明可以不写, 会在__init__方法里自动声明且赋值

    def __init__(self, name, gender, age):
        self.name = name
        self.gender = gender
        self.age = age
        print("Student类创建了一个对象")

# 创建对象
stu1 = Student("HONGHONG", "male", 17)
print(stu1.name)
print(stu1.gender)
print(stu1.age)
# 练习
class Student:

    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address

num = input("请输入本次需要录入信息的学生数量:")
for i in range(int(num)):
    print(f"当前录入第{i + 1}位学生信息, 总共需要录入{num}位学生信息")
    name = input("请输入学生姓名:")
    age = input("请输入学生年龄:")
    address = input("请输入学生地址:")
    stu = Student(name, age, address)
    print(f"学生{i + 1}信息录入完成, 信息为: 【学生姓名: {stu.name}, 年龄: {stu.age}, 地址: {stu.address}")
print("所有学生信息录入完毕")


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 其它内置方法, 称为魔术方法
"""
python有二三十个内置方法, 除了上面的__init__, 这里只学习4个常见的

__str__ 字符串方法
__lt__ 小于、大于符号比较
__le__ 小于等于、大于等于符号比较
__eq__ ==符号比较
"""
# __str__
class Student:

    def __init__(self, name, age, address):
        self.name = name
        self.age = age
        self.address = address
stu = Student("zhangsan", 22, "beijing")
print(stu)# 输出为<__main__.Student object at 0x00000260A5585A90>
print(str(stu))# 输出同上, 都是输出stu在内存中的存储地址
# 但是对象的存储地址一般作用不大, 通过__str__方法, 控制类转换为字符串的行为
class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"Student类对象, name={self.name},  age={self.age}"

stu = Student("zhangsan", 22)
print(stu)# 输出为Student类对象, name=zhangsan,  age=22
print(str(stu))# 输出为Student类对象, name=zhangsan,  age=22


# __lt__
class Student:

    def __init__(self, name, age, address):
        self.name = name
        self.age = age

stu1 = Student("liuliu", 22)
stu2 = Student("bangbang", 20)
print(stu1 > stu2)
# 报错TypeError: '>' not supported between instances of 'Student' and 'Student'

class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __lt__(self, other):# __lt__方法自带, 表示另一个对象
        return self.age < other.age# 定义要比较两个对象的age

stu1 = Student("liuliu", 22)
stu2 = Student("bangbang", 20)
print(stu1 > stu2)# 输出True
print(stu1 < stu2)# 输出False


# __le__
class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __lt__(self, other):# __lt__方法自带, 表示另一个对象
        return self.age < other.age# 定义要比较两个对象的age

stu1 = Student("liuliu", 22)
stu2 = Student("bangbang", 20)
print(stu1 >= stu2)
print(stu1 <= stu2)
# 报错TypeError: '>=' not supported between instances of 'Student' and 'Student'
# 这是因为, 尽管定义了__lt__方法, 但是类仍然不支持<=和>=
class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __le__(self, other):
        return self.age <= other.age

stu1 = Student("liuliu", 22)
stu2 = Student("bangbang", 20)
stu3 = Student("bingbing", 22)
print(stu1 >= stu2)# 输出为True
print(stu1 <= stu2)# 输出为False
print(stu1 >= stu3)# 输出为True


# __eq__
class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age

stu1 = Student("liuliu", 22)
stu2 = Student("bangbang", 20)
stu3 = Student("bingbing", 22)
print(stu1 == stu3)# 输出为False=====================>不定义__eq__方法==默认比较内存地址, 那么两个对象的内存地址当然不相等

class Student:

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        return self.age == other.age

stu1 = Student("liuliu", 22)
stu2 = Student("bangbang", 20)
stu3 = Student("bingbing", 22)
print(stu1 == stu2)# 输出为False
print(stu1 == stu3)# 实现__eq__方法之后输出为True


# ===================================================已补充===========================================================
# 面向对象编程, 是许多编程语言都支持的一种编程思想
# 最简单的理解是, 基于模板(类)去创建实体(对象),使用对象完成功能开发

# 面向对象包含3大主要特征:
#    封装
#    继承
#    多态


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 封装
"""
# 封装概念
封装表示的是, 将现实世界事物的属性和行为封装到类中, 描述为成员变量和成员方法, 从而实现程序对现实世界事物的描述

# 私有成员的使用
现实世界的事物有不公开的属性和行为, 比如手机的重量品牌和拍照上网等属性和行为公开, 但是运行电压、驱动信息等属性不公开
程序调度、内存管理等行为也不公开, 即对用户隐藏的属性和行为
既然现实世界的事物是这样的, 那么作为对现实世界事物在程序中映射的类, 当然也要支持不公开的属性和行为, 即私有成员
私有成员变量和私有成员方法
定义方法:在私有成员变量或私有成员方法的名称前面以__开头
"""
class Phone:
    IMEI = None
    producer = None

    __current_voltage = None# 私有成员变量

    def call_by_5g(self):
        print("5g通话已开启")
    
    def __keep_single_core(self):# 私有成员方法
        print("让CPU以单核模式运行以节省电量")
"""
现实世界中的隐藏属性和行为用户无法知晓, 那么私有成员变量和私有成员方法是否也无法被用户使用呢, 答案是无法被用户使用
通过上面创建的Phone类创建对象, 然后使用私有方法, 会报错如下:
"""
phone = Phone()
phone.__keep_single_core()# 使用私有方法
"""
    phone.__keep_single_core()# 使用私有方法
    ^^^^^^^^^^^^^^^^^^^^^^^^
AttributeError: 'Phone' object has no attribute '__keep_single_core'. Did you mean: '_Phone__keep_single_core'?
"""
phone.__current_voltage = 33# 对私有变量赋值
print(phone.__current_voltage)# 获取私有变量值
"""
不会报错, 但赋值失败
下一句print报错无法获取
为什么我自己试的时候成功了?
# ===================================================已补充===========================================================
你这个问题问得非常好, 而且代表了很多初学者第一次接触 Python “私有变量”时的困惑。我们先明确两个核心事实, 然后用 **最简单的比喻 + 代码实验** 来解释你为何“视频中失败了”, 你却“成功了”。

最核心的两件事
1. **在类中用双下划线（`__xx`）定义的变量或方法是“伪私有”**, Python 会自动将它改名（重命名）为 `_类名__xx`, 这是“名称改写机制”（name mangling）。
2. 如果你在类外部使用 `obj.__xx = 123`, Python 会认为你在创建一个**新的实例变量**, **不是在修改那个类里面的私有变量**。
用一个简单类来“亲自验证”
你只需要复制粘贴下面这段完整代码, 就能看出你看到的“成功”其实是**误解了自己操作的对象**。
class Phone:
    __current_voltage = 0  # 私有变量

    def show_voltage(self):
        print("真正的私有变量值是:", self.__current_voltage)

phone = Phone()
phone.__current_voltage = 33  # ❗注意: 这不会报错, 但不会修改类中的私有变量
print("外部访问 __current_voltage:", phone.__current_voltage)  # ✅ 打印出 33, 但这不是类里的那个变量
# 查看 phone 实例内部所有变量名
print("实例变量:", phone.__dict__)  # 看看有哪些“真的变量”
# 用类内的方法来访问私有变量
phone.show_voltage()  # 看看到底 __current_voltage 变了没有
运行结果: 
外部访问 __current_voltage: 33
实例变量: {'__current_voltage': 33}
真正的私有变量值是: 0

解释: 
* 你赋值的 `phone.__current_voltage = 33` 是一个**新的变量**, 和类中的私有变量没有关系。
* `phone.show_voltage()` 调用了类里面的方法, 它访问的是被改名为 `_Phone__current_voltage` 的那个真正的“私有变量”, 值还是 `0`。
* 所以你**以为你“赋值成功”了, 其实你赋的是个假的变量。**

## 🔐 如果真的要修改类中私有变量怎么办？
用类内的方法修改, 或者用“改名后的真实变量名”: 
phone._Phone__current_voltage = 99
phone.show_voltage()  # 真正改成功了
回答你的问题: 为什么老师的视频“失败了”, 你却“成功了”？
因为: 

* 老师的意思是: **不能通过 `obj.__xx = 123` 修改类内部的私有变量** —— 这是**逻辑上“失败”了**, 虽然你代码不会报错。
* 而你看到代码没报错、还能 `print()` 出值, 就以为“成功了”。
* 实际上你是给实例新加了个变量, 不是访问原来的私有变量。
所以你和老师说的“成功”与“失败”其实指的是不同的东西。

最重要的记忆点

| 写法                  | 是否访问到类里的私有变量？  | 说明                |
| ------------------- | -------------- | ----------------- |
| `obj.__xx = val`    | ❌ 失败, 创建新变量     | 看起来成功, 其实是“假象”     |
| `print(obj.__xx)`   | ❌ 打印的是新变量      | 你以为访问成功了, 其实访问的是假的 |
| `obj._类名__xx = val` | ✅ 真正修改了类里的私有变量 | 不推荐常用, 但能证明原理      |
| `类内方法访问 self.__xx`  | ✅ 正常访问         | 推荐使用方式            |
"""

# 私有成员变量和方法既然无法被用户使用, 还有要存在的必要吗
"""
举例, 手机的程序调度和内存管理虽然对用户不公开, 但是手机内部会使用, 比如手机拍照运行前会判断电压情况等
私有成员变量和方法同理, 是给类内部其他方法去使用的, 举例如下代码:
"""
class Phone:
    __current_voltage = 0.5  # 当前电压

    def __keep_single_core(self):  # 私有成员方法
        print("让CPU以单核模式运行以节省电量")

    def call_by_5g(self):
        if self.__current_voltage >=1:
            print("5g通话已开启")
        else:
            self.__keep_single_core()
            print("电量不足, 无法使用5g通话, 并已设置为单核运行进入省点模式")

phone = Phone()
phone.call_by_5g()
"""
练习:
设计一个手机类, 内部包含:
    私有成员变量, __is_5g_enable,类型bool,True表示开始5g,False表示关闭5g
    私有成员方法, __check_5g(), 会判断私有成员__is_5g_enable的值
        若为True, 打印输出5g开启
        若为False, 打印输出5g关闭, 使用4g网络
    公开成员方法, call_by_5g(),调用它会执行
        调用私有成员方法__check_5g()判断5g网络状态
        打印输出, 正在通话中
运行结果:
5g关闭, 使用4g网络
正在通话中
"""
class Phone:
    __is_5g_enable = False

    def __check_5g(self):
        if self.__is_5g_enable:
            print("5g开启")
        else:
            print("5g关闭, 使用4g网络")

    def call_by_5g(self):
        self.__check_5g()
        print("正在通话中")

phone = Phone()
phone.call_by_5g()


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 继承

# 继承的概念和使用
"""
如果几代手机的外形改变微乎其微, 那么会选择每一代新手机都从零开始出设计图还是基于老款的设计图修修改改呢
一定是选择后者, 程序中也是一样
之前的手机类代码如下 
"""
class Phone:
    IMEI = None
    producer = None

    def call_by_4g(self):
        print("4g通话已开启")
"""
后来随着发展有了面部识别功能和5g网络, 就重新写了手机类
"""
class Phone2022:
    IMEI = None
    producer = None
    face_id = True

    def call_by_4g(self):
        print("4g通话已开启")
    
    def call_by_5g(self):
        print("2022最新5g通话已开启")
"""
但是从零开始设计类就很繁琐, 在原版基础上修修改改就比较方便了
那么如何在原版基础上修修改改呢, 就用到了继承功能
"""
class Phone:
    IMEI = "35856262893983764"
    producer = "Apple"

    def call_by_4g(self):
        print("4g通话已开启")

class Phone2022(Phone):# ===================>表示继承Phone类的所有内容
    face_id = True
    
    def call_by_5g(self):
        print("2022最新5g通话已开启")
"""
会发现, 新的类只增加了两个新内容, 老功能都没有写

继承的定义方式:
class 类名(父类名):
    类内容体
分别被称为父类和子类
"""
phone = Phone2022()
phone.call_by_4g()# 输出成功, 说明继承成功
print(phone.IMEI)# 输出成功, 说明继承成功
print(phone.producer)# 输出成功, 说明继承成功
phone.call_by_5g()# 输出成功, 说明创建成功
print(phone.face_id)# 输出成功, 说明创建成功
"""
继承有单继承和多继承两种方式
单继承:一个子类继承一个父类, 上面已经演示过了
多继承:一个子类继承多个父类
class 类名(父类1, 父类2, ······ 父类N):
    类内容体

举例:
小米手机集成了手机、NFC读卡器、红外遥控器三个的功能,简单写一个小米手机的类如下:
"""
class Phone:
    IMEI = None
    producer = "Apple"

    def call_by_5g(self):
        print("2022最新5g通话已开启")

class NFCReader:
    nfc_type = "第五代"
    producer = "HM"

    def read_card(self):
        print("读取NFC卡")

    def write_card(self):
        print("写入NFC卡")

class RemoteControl:
    rc_type = "红外遥控"

    def control(self):
        print("红外遥控开启")

class MyPhone(Phone, NFCReader, RemoteControl):
    pass# pass关键字的作用: 用来补全语法, 让语法不报错同时pass所在位置为空

phone = MyPhone()
phone.call_by_5g()
phone.read_card()
phone.write_card()
phone.control()
print(phone.nfc_type)
print(phone.IMEI)
print(phone.producer)# 输出为Apple, 也就是继承Phone的producer
"""
两个父类中都有producer, 以哪个为准呢?
多继承注意事项:
如果多个父类中, 有同名的成员, 默认以继承顺序(从左到右)为优先级
即:先继承的保留, 后继承的被覆盖
"""
class MyPhone(NFCReader, RemoteControl, Phone):# 改一下继承顺序
    pass
print(phone.producer)# 输出为HM, 即继承RemoteControl的producer


# 复写父类成员的方法
"""
复写:子类在继承父类的成员属性和成员方法后, 如果对其'不满意',就可以进行复写
即:在子类中重新定义同名的属性和方法即可
"""
class Phone:
    IMEI = None
    producer = "Apple"

    def call_by_5g(self):
        print("父类5g通话已开启")

class MyPhone(Phone):
    producer = "HM"   # 复写父类属性

    def call_by_5g(self):
        print("子类5g通话已开启")   # 复写父类方法

phone = MyPhone()
phone.call_by_5g()# 输出为子类5g通话已开启
print(phone.IMEI)# 输出为None
print(phone.producer)# 输出为HM


# 如何在子类中调用父类同名成员
"""
一旦调用父类成员, 那么类对象调用成员的时候, 就会调用复写后的新成员
如果需要使用被复写的父类成员, 需要特殊的调用方式:
方式一:
调用父类成员
    使用成员变量: 父类名.成员变量
    使用成员方法: 父类名.成员方法(self)
方式二:
使用super()调用父类成员
    使用成员变量: super().成员变量
    使用成员方法: super().成员方法()# 注意这里括号内没有self
为什么要调用父类同名成员: 说白了就是变量和方法都具有了两套逻辑, 适合在不同的情况下选用或借用
"""
class Phone:
    IMEI = None
    producer = "Apple"

    def call_by_5g(self):
        print("5g通话已开启")

class MyPhone(Phone):
    producer = "HM"   # 复写父类属性

    def call_by_5g(self):
        print("开启CPU单核运行")
        Phone.call_by_5g(self)# 或者使用super().call_by_5g()
        print("关闭CPU单核运行")
        print(f"父类的厂商是{Phone.producer}")#或者使用{super().producer}

phone = MyPhone()
phone.call_by_5g()
print(phone.IMEI)
print(phone.producer)
"""
输出依次为:
开启CPU单核运行
5g通话已开启
关闭CPU单核运行
父类的厂商是Apple
None
HM
"""


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 类型注解


# 变量的类型注解
"""
为什么使用类型注解:
pycharm的自动提示功能, 为什么它能够做到这一点呢, 因为pycharm可以确定当前对象是什么类型, 之后可以根据该类支持哪些方法进行提示
python在3.5版本的时候引入了类型注解, 以方便静态类型检查工具, IDE等第三方工具
类型注解: 在代码中涉及数据交互的地方, 提供数据类型的注解(显示的说明)
主要功能:
    帮助第三方IDE工具(如Pycharm)对代码进行类型推断, 协助做代码提示
    帮助开发者自身对变量进行类型注释
支持:
    变量的类型注解
    函数(方法)形参列表和返回值的类型注解
"""
# 变量的类型注解方式一
"""
语法:
变量:类型

基础数据类型注解
var_1: int = 10
var_2: folat = 3.14
var_3: bool = True
var_4: str = 'HM'

类对象类型注解
class Student:
    pass
stu: student = Student()# stu是一个student类型的对象

基础容器类型注解
my_list: list = [1, 2, 3]
my_tuple: tuple = (1, 2, 3)
my_set: set = {1, 2, 3}
my_dictL dict = {'HM': 666}
my_str: str = 'HM666'

# 除了简单注解还可以详细注解
容器类型详细注解
my_list: list[int] = [1, 2, 3]# 对list内元素的类型进行了详细注解
my_tuple: tuple[str, int, bool] = ('HM', 2, True)# 注意, 元祖类型设置类型详细注解, 需要将每一个元素都标记出来
my_set: set[int] = {1, 2, 3}
my_str: str = 'HM666'
my_dictL dict[str, int] = {'HM': 666}# 字典类型设置类型详细注解, 需要2个类型, 第一个是key第二个是value======>那么每个键值对的类型不同怎么
办, 比如my_dict = {'姓名': “zhangsan”, "score": {"英语": 99, "数学":98}}
# ===================================================已补充===========================================================
你问得非常好, 字典的类型注解在复杂结构下确实需要更细致的方式来表达。我们逐步解释: 
基础语法复习: 标准字典类型注解
my_dict: dict[str, int] = {'HM': 666}
这表示: **键是 `str`, 值是 `int`**。
那如果字典中每个键的值类型不同怎么办？
像你这个例子: 
my_dict = {
    '姓名': 'zhangsan',        # 值是 str
    'score': {'英语': 99, '数学': 98}  # 值是另一个字典
}

这属于“**混合类型的字典**”, 那就不能简单写成 `dict[str, str]` 或 `dict[str, int]`, 而是有两种选择: 
方法一: 使用 `dict[str, Any]` （灵活但不具体）
from typing import Any

my_dict: dict[str, Any] = {
    '姓名': 'zhangsan',
    'score': {'英语': 99, '数学': 98}
}
* `Any` 表示可以是任何类型, 最灵活
* 缺点: 不明确指出每个键的具体类型

方法二: 使用 `TypedDict`（推荐, 结构清晰）
from typing import TypedDict

class StudentInfo(TypedDict):
    姓名: str
    score: dict[str, int]

my_dict: StudentInfo = {
    '姓名': 'zhangsan',
    'score': {'英语': 99, '数学': 98}
}
优点: 
* 明确指定每个键的类型
* IDE（如 PyCharm 或 VS Code）能自动补全、报错提示
总结对比
| 方式               | 表达能力    | 推荐使用场景          |
| ---------------- | ------- | --------------- |
| `dict[str, Any]` | 灵活、粗略   | 键固定但值不确定、快速原型   |
| `TypedDict`      | 严格、结构清晰 | 键和值都清楚、有结构的复杂字典 |



# 提问:
例如这个定义
class ScoreDict(TypedDict):
    英语: int
    数学: int
    语文: int
英语数学语文的分数不需要给一个声明值比如None吗, 可以直接不写值吗
# 回答:
非常好的问题！我们来具体解释: 
简单回答: 
**在定义 `TypedDict` 的时候, 不需要给每个字段赋值（比如 `None`）, 你只需要声明字段名和类型。**
class ScoreDict(TypedDict):
    英语: int
    数学: int
    语文: int

这是**类型声明**, 不是字典的实际内容。相当于是在说: “任何一个 `ScoreDict` 类型的字典, **必须**包含这三个键, 而且它们的值必须是 `int` 类型。”
不要这么写: 
class ScoreDict(TypedDict):
    英语: int = None  # ❌ 错误, 这不是 `TypedDict` 的语法
`TypedDict` 不是普通类, 它不是用来初始化字段值的。你只需要说明“键”和“值的类型”。
类比理解
| 类型          | 用途                   |
| ----------- | -------------------- |
| `TypedDict` | **描述字典的结构和字段类型**     |
| `dataclass` | **定义类结构并可提供默认值、方法等** |

如果你希望某些字段是**可选的**怎么办？
你可以使用 `total=False` 或 `NotRequired`: 
方法 1: `total=False`（整个字典的字段都可以省略）
class ScoreDict(TypedDict, total=False):
    英语: int
    数学: int
    语文: int

这表示这些字段是可选的。

方法 2: Python 3.11+ 新写法: `NotRequired`
from typing import TypedDict, NotRequired

class ScoreDict(TypedDict):
    英语: int
    数学: int
    语文: NotRequired[int]  # 这个字段是可选的

示例: 正确使用方式
class ScoreDict(TypedDict):
    英语: int
    数学: int
    语文: int

score: ScoreDict = {
    "英语": 98,
    "数学": 95,
    "语文": 88
}
总结
| 你想要的效果          | 推荐做法                            |
| --------------- | ------------------------------- |
| 只是说明字典中有哪些字段和类型 | 使用 `TypedDict`, 不赋值              |
| 希望字段有默认值        | 使用 `dataclass`                  |
| 希望字段可选          | 用 `total=False` 或 `NotRequired` |
"""
# 变量的类型注解方式二 在注释中进行类型注解
"""
语法:
# type: 类型
def func():
    return 3

var_1 = random.randint(1, 10)    # type: int                 #===========>在pycharm中原本灰色的注释, int会变亮, 说明注释注解起作用了
var_2 = json.loads(data)         # type: dict[str, int]
var_3 = func()                   # type: int
"""
# 变量的类型注解注意事项
"""
1、为变量设置注解, 显示的变量定义, 一般无需注解
比如
var_1: int = 10
var_2: folat = 3.14
var_3: bool = True
var_4: str = 'HM'
就算不写注解, 也明确的知晓变量的类型

2、一般, 无法直接看出变量类型的时候, 会添加变量的类型注解
比如:
def func():
    return 3

var_1: int = random.randint(1, 10)
var_2: dict = json.loads(data)
var_3: int = func()

3、类型注解只是做备注用的, 并不会真正的对类型做验证和判断, 即类型注解仅仅是提示性的, 不是决定性的
var_1: int = 'HM'
var_4: str = 10
上面的两行代码不会报错
"""


# 函数(方法)的类型注解
# 为函数(方法)形参进行类型注解
"""
语法:
def 函数方法名(形参名: 类型, 形参名: 类型, ······):# 和变量类型注解很相似
    pass
"""
def add(x: int, y:int):
    return x + y

def func(data: list):
    pass
# 为函数(方法)返回值进行类型注解
"""
语法:
def 函数方法名(形参名: 类型, 形参名: 类型, ······) -> 返回值类型:      # -> 返回值类型就是对返回值进行注解
    pass
"""
def func(data: list) -> list:# 表示返回值是list类型
    pass
"""
同样的, 形参和返回值的类型注解都不是强制性的, 只起到备注和提示作用
"""


# Union类型
"""
# Union类型

# 使用Union进行联合类型注解
对于下面的list和dict会发现, 它们的元素类型不是单一的, 不能仅仅通过一种类型去表达, 所以可以用Union进行联合类型注解
使用Union进行联合类型注解语法:
    导包: from typing import Union
    使用: Union[类型,  类型,  ······,  类型]
"""
my_list = [1, 2, "HM", "IT"]
my_dict = {"name": "honghong", "age": 20}

from typing import Union
my_list: list[Union[str, int]] = [1, 2, "HM", "IT"]# 表示元素有可能是int类型有可能是str类型
my_dict: dict[str, Union[str, int]] = {"name": "honghong", "age": 20}# 表示value有可能是int类型有可能是str类型
def func(data: Union[str, int]) -> Union[str, int]:# 对函数形参和返回值也同样适用
    pass


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 多态

# 多态: 多种状态, 即完成某个行为时, 使用不同的对象会得到不同的状态
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        print("汪汪汪")

class Cat(Animal):
    def speak(self):
        print("喵喵喵")

def make_noise(animal: Animal):
    animal.speak()

dog = Dog()
cat = Cat()
make_noise(dog)# 输出汪汪汪
make_noise(cat)# 输出喵喵喵
"""
多态常作用在继承关系上
比如, 函数(方法)形参声明接受父类对象, 实际传入父类的子类对象进行工作(上面的示例代码就是这样)
即:
    以父类做定义声明
    以子类做实际工作
    用以获得同一行为, 不同状态
"""

# 抽象类(接口)的编程思想   多态也经常用在抽象类的使用场景
"""
在上面的举例代码中, 父类Animal的speak方法实现为空, 这种设计的含义是:
    父类用来确定有哪些方法
    具体的方法实现, 由子类自行决定
这种写法, 就叫抽象类(也可以称之为接口)

抽象类: 含有抽象方法的类称之为抽象类
抽象方法: 方法体是空实现(pass)的称之为抽象方法

举例: 现实生活中, 要设计一款空调, 那么简化一下, 它有制冷、制热、左右摆风三个行为, 但是格力和美的各自的实现技术肯定是不一样的
设计一个空调的抽象类和它的两个子类如下:
"""
class AC:
    def cold_wind(self):
        """制冷"""
        pass

    def hot_wind(self):
        """制热"""
        pass

    def swing_left_right(self):
        """左右摆风"""
        pass

class Midea_AC(AC):
    def cold_wind(self):
        """制冷"""
        print("美的空调制冷")

    def hot_wind(self):
        """制热"""
        print("美的空调制热")

    def swing_left_right(self):
        """左右摆风"""
        print("美的空调左右摆风")

class Gree_AC(AC):
    def cold_wind(self):
        """制冷"""
        print("格力空调制冷")

    def hot_wind(self):
        """制热"""
        print("格力空调制热")

    def swing_left_right(self):
        """左右摆风"""
        print("格力空调左右摆风")
"""
抽象类的作用是一种顶层抽象、顶层设计,类似生活中设计一个标准, 真正工作的是子类
上面的例子中, 美的和格力空调都继承了AC抽象类, 并且将其中的方法都各自实现了
有了抽象类和子类, 就可以配合多态, 完成:
    抽象的父类设计(设计标准)
    具体的子类实现(实现标准)
"""
def make_cool(ac: AC):
    ac.cold_wind()

midea_ac = Midea_AC()
gree_ac = Gree_AC()
make_cool(midea_ac)# 输出美的空调制冷
make_cool(gree_ac)# 输出格力空调制冷


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 综合案例
"""
数据分析案例
1、使用面向对象思想完成数据读取和处理
2、基于面向对象思想重新认知第三方库使用(pyecharts)
某公司的2份数据文件, 对其进行分析处理, 计算每日的销售额并以柱状图表的形式对其进行展示
见daily_sales_volume_practice.py
"""
