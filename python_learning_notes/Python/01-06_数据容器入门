# 方法的概念
# 不同的容器以及不同容器的不同方法适合用在不同的场景下,积累一下使用场景
# 一个东西被发明出来就是为了满足一定的场景,找到这个场景,为什么这样设计,是否可以用在其他场景解决其他问题,设计有没有可以借鉴的地方,学习计算机解决问题的思维
/* ===================================================待补充===========================================================*/


# ===============================================================第六章 数据容器入门== =============================================================
"""
一共6种数据类型,除数字类型外都是数据容器
数据容器5种中:列表、元组、字符串为序列,集合、字典无序
是否支持下标索引:
    序列支持,非序列当然不支持
是否支持重复元素:
    序列支持,非序列不支持
是否可修改:
    列表√
    元组、字符串X
    集合、字典√
"""

/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# list列表
"""
特点:
可以容纳多个元素(上限为2**63-1个)
可以容纳不同数据类型的元素
数据是有序存储的
允许重复数据存在
可以修改(增删改等)
支持while和for循环
"""


/*列表的定义*/
"""
列表内的每个数据称之为元素
[],每个元素之间用逗号,隔开
# 字面量
    [元素1, 元素2, 元素3, 元素4, ···]
# 定义变量
    变量名称 = [元素1, 元素2, 元素3, 元素4, ···]
# 定义空列表
    变量名称 = []
    变量名称 = list()

列表可以一次存储多个数据,且可以为不同的数据类型,支持嵌套
"""
name_list = ["lanlan", "honghong", "mingming"]
my_list = ["lanlan", 23, True]
num_list = [[1, 2, 3], [4, 5, 6]]


/*列表的下标索引: 取出特定位置的数据*/
# 元素顺序按照从左到右下标为0 1 2 3 ···
name_list = ["lanlan", "honghong", "mingming"]
print(name_list[0])# 结果为lanlan
print(name_list[1])# 结果为honghong
print(name_list[2])# 结果为mingming
# 可以反向索引,从右向左,从-1开始,-1 -2 -3 ···
print(name_list[-1])# 结果为mingming
print(name_list[-2])# 结果为honghong
print(name_list[-3])# 结果为lanlan
# 嵌套列表的索引
print(num_list[0][0])# 结果为1
print(num_list[1][1])# 结果为5
# 下标索引不要超出取值范围,否则会报错

/*列表的常用操作,也叫列表的方法*/
# 方法的概念
"""
函数是一个封装的代码单元,可以提供特定功能
python中,如果将函数定义为class(类)的成员,那么函数会称之为方法,如
函数:
def add(self, x, y):
    return x + y
方法:
class Student:

    def add(self, x, y):
        return x + y
所以,方法和函数功能一样,有传参,有返回值,只是方法的使用格式不同
函数的使用:
num = add(1, 2)
方法的使用:
student = Student()
num = student.add(1, 2)
"""
# 通过上面方法的介绍,以下操作都是list列表的方法,也就是说python中在list这个类下面定义了很多的函数


"""
# 查询某元素下标
功能:查询制定元素在列表的下标,如果找不到就报错ValueError
语法:列表.index(元素)   ============>  index就是列表对象(变量)内置的方法(函数)
"""
name_list = ["lanlan", "honghong", "mingming"]
index1 = name_list.index("honghong")
print(index1)# 结果为1

num_list = [[1, 2, 3], [4, 5, 6]]
index2 = num_list.index(5)
print(index2)#报错,说5不在num_list里
# 这是因为这个嵌套列表中的元素为两个列表而不是某个单一的数据
# 所以这个index的功能是不能嵌套查询的


"""
# 修改特定位置(索引)的元素值
语法:列表[下标] = 值
"""
name_list[1] = "qingqing"
print(name_list)# 结果为['lanlan', 'qingqing', 'mingming']
num_list[1][1] = 13
print(num_list)# 结果为[[1, 2, 3], [4, 13, 6]]


"""
# 插入元素
语法:列表.insert(下标, 元素),在指定的下标位置,插入指定的元素
"""
name_list.insert(1, "jingjing")
print(name_list)# 结果为['lanlan', 'jingjing', 'qingqing', 'mingming']
num_list.insert(1, "jingjing")
print(num_list)# 结果为[[1, 2, 3], 'jingjing', [4, 13, 6]]


"""
# 追加元素
语法:列表.append(元素),将指定元素追加到列表的尾部
语法:列表.extend(其他数据容器),将其他数据容器的内容取出,依次追加到列表尾部
"""
num_list.append([16, 17, 18])
print(num_list)# 结果为[[1, 2, 3], 'jingjing', [4, 13, 6], [16, 17, 18]]
num_list.extend([20, 21, 22])
print(num_list)# 结果为[[1, 2, 3], 'jingjing', [4, 13, 6], [16, 17, 18], 20, 21, 22]
num_list2 = [79, 80, 81]
num_list.extend(num_list2)
print(num_list)# 结果为[[1, 2, 3], 'jingjing', [4, 13, 6], [16, 17, 18], 20, 21, 22, 79, 80, 81]
# 注意是把20, 21, 22和79, 80, 81分别当做元素添加到了num_list中,而不是把[20, 21, 22]或num_list2当做一个整体加入到num_list中
# 所以要理解这句“将其他数据容器的内容取出,依次追加到列表尾部”


"""
# 删除元素
语法1:del 列表[下标]
语法2:列表.pop(下标)   ========>   pop这个方法的本质其实是将指定下标的元素从列表中取出来返回回去,所以可以用变量接收

# 删除某个元素在列表中的第一个匹配项
    即通过内容删除,从前到后去搜索这个元素,只能删除与内容匹配的第一个元素而不能将匹配的所有元素都删除
    能实现将匹配的所有元素都删除吗   ============>见第二个已补充
语法:列表.remove(元素)
"""
del num_list[7]
print(num_list)# 结果为[[1, 2, 3], 'jingjing', [4, 13, 6], [16, 17, 18], 20, 21, 22, 80, 81]
del num_list[7, 8, 9]# 报错TypeError: list indices must be integers or slices, not tuple,这个问题等后面学了slices再说

element = num_list.pop(7)
print(num_list)# 结果为[[1, 2, 3], 'jingjing', [4, 13, 6], [16, 17, 18], 20, 21, 22, 81]
print(element)# 结果为80

name_list = ["lanlan", "honghong", "mingming"]
name_list.remove("honghong")
print(name_list)# 结果为['lanlan', 'mingming']
name_list = ["lanlan", "honghong", "mingming", "honghong", "mingming"]
name_list.remove("honghong")
print(name_list)# 结果为['lanlan', 'mingming', 'honghong', 'mingming'],只把第一个honghong删掉了
# 我想一次删除多个,怎么实现呢
/* ===================================================已补充===========================================================*/
"""
在 Python 中,如果你想一次删除多个列表元素(但不是全部),有几种常见的方法,具体选择取决于你的需求。以下是详细的解决方案:

方法1:使用 del + 切片(Slice)
适用场景:删除连续位置的多个元素(如删除下标 1~3 的元素)。
lst = [10, 20, 30, 40, 50, 60]
del lst[1:4]  # 删除下标1到3的元素(左闭右开区间)
print(lst)    # 输出: [10, 50, 60]

方法2:使用列表推导式(List Comprehension)
适用场景:按条件删除多个非连续元素(如删除所有偶数)。
lst = [1, 2, 3, 4, 5, 6]
lst = [x for x in lst if x % 2 != 0]  # 保留奇数
print(lst)  # 输出: [1, 3, 5]

方法3:使用 pop() 循环(不推荐)
适用场景:删除多个已知下标的元素(需从后往前删,避免下标错乱)。
lst = ['a', 'b', 'c', 'd', 'e']
indices = [1, 3]  # 要删除的下标列表
for i in sorted(indices, reverse=True):  # 从后往前删
    lst.pop(i)
print(lst)  # 输出: ['a', 'c', 'e']

方法4:使用 numpy(适合大数据量)
适用场景:需要高效处理大型列表。
import numpy as np
lst = [10, 20, 30, 40, 50]
mask = [False, True, False, True, False]  # True表示要删除的元素
lst = np.array(lst)[~np.array(mask)].tolist()
print(lst)  # 输出: [10, 30, 50]

方法5:使用 filter() 函数
适用场景:通过函数条件过滤元素。
lst = [1, 2, 3, 4, 5]
lst = list(filter(lambda x: x > 2, lst))  # 保留大于2的元素
print(lst)  # 输出: [3, 4, 5]
总结对比表
方法	     优点	               缺点	                        适用场景
del + 切片	 高效,直接修改原列表	只能删除连续元素	           删除连续区间
列表推导式	 灵活,支持复杂条件	    创建新列表,可能占用额外内存	    按条件删除非连续元素
pop() 循环	 精确控制单个下标	   需反向操作,易出错	           删除少量非连续下标
numpy	    适合大数据量操作	   需安装第三方库	              科学计算或大型数据集
filter()	函数式编程风格	       返回迭代器,需转列表	          按函数条件过滤
关键注意事项
下标越界问题:删除多个下标时,确保下标合法。

性能考虑:
小列表:任意方法均可。
大列表:优先选择 del 切片或 numpy。
是否需要保留原列表:
直接修改原列表:del 或 pop()。
创建新列表:列表推导式或 filter()。

示例:混合删除(非连续下标)
如果需要删除多个非连续下标(如删除下标为 [0, 2, 4] 的元素):
lst = ['a', 'b', 'c', 'd', 'e', 'f']
indices = {0, 2, 4}  # 用集合提高查找效率
lst = [x for i, x in enumerate(lst) if i not in indices]
print(lst)  # 输出: ['b', 'd', 'f']
选择方法时,根据数据规模、删除条件和代码可读性权衡即可。
"""
# 列表.remove(元素)删除某个元素在列表中的第一个匹配项,如何实现将匹配的所有元素都删除
语法:列表.remove(元素)
"""
在 Python 中,list.remove(元素) 只能删除列表中第一个匹配的元素,无法直接一次性删除所有匹配项。但可以通过以下方法实现删除所有匹配元素的操作:

方法1:循环 + remove()(不推荐)
问题:直接循环中调用 remove() 会因列表动态变化导致漏删或错误。
lst = [1, 2, 2, 3, 2]
while 2 in lst:  # 循环直到所有2被删除
    lst.remove(2)
print(lst)  # 输出: [1, 3]
⚠️ 缺陷:每次 remove() 需要遍历列表,时间复杂度为 O(n²),效率低。

方法2:列表推导式(推荐)
原理:创建新列表,仅保留不匹配的元素。
lst = [1, 2, 2, 3, 2]
lst = [x for x in lst if x != 2]  # 保留所有不等于2的元素
print(lst)  # 输出: [1, 3]
✅ 优点:

时间复杂度 O(n),效率高。

代码简洁,Pythonic 风格。

方法3:使用 filter() 函数
原理:通过过滤函数生成新列表。
lst = [1, 2, 2, 3, 2]
lst = list(filter(lambda x: x != 2, lst))  # 过滤掉所有2
print(lst)  # 输出: [1, 3]
🌐 适用场景:适合函数式编程风格。

方法4:直接修改原列表(通过切片赋值)
原理:利用切片赋值直接覆盖原列表。
lst = [1, 2, 2, 3, 2]
lst[:] = [x for x in lst if x != 2]  # 切片赋值修改原列表
print(lst)  # 输出: [1, 3]
💡 优势:避免创建新变量,直接修改原列表对象。

方法5:使用 collections.defaultdict(统计后重建,适合复杂条件)
原理:统计需保留的元素,重新构建列表。
from collections import defaultdict
lst = [1, 2, 2, 3, 2]
count = defaultdict(int)
for x in lst:
    count[x] += 1
del count[2]  # 标记删除所有2
lst = [x for x in lst if x in count]  # 重建列表
print(lst)  # 输出: [1, 3]
🔍 适用场景:需要先统计或复杂条件过滤时。

性能对比
方法	时间复杂度	空间复杂度	是否修改原列表	代码简洁性
循环 + remove()	O(n²)	O(1)	✔️	❌
列表推导式	O(n)	O(n)	❌(需赋值)	✔️
filter()	O(n)	O(n)	❌	✔️
切片赋值	O(n)	O(n)	✔️	✔️
defaultdict	O(n)	O(n)	❌	❌
终极方案:一行代码解决
python
lst = [x for x in lst if x != 2]  # 最Pythonic的方式
总结
推荐方法:优先使用列表推导式(方法2)或切片赋值(方法4),兼顾效率和代码可读性。

避免踩坑:不要在循环中直接修改原列表(如 for x in lst: lst.remove(x)),否则会导致意外行为。

扩展思考:如果列表元素是复杂对象,可将条件改为 if not x.is_deleted 等自定义逻辑。
"""


"""
# 清空元素
语法:列表.clear()
也可以直接用一个空列表给原来的列表赋值来实现吧,这和clear的方法在实现上有什么区别吗(下面的集合和字典中的clear()用法也是同理)
一、列表(List)的 clear() vs lst = []
1. 核心区别
行为	        lst.clear()                   lst = []
原列表对象	     仍为同一个对象(内存地址不变)	 创建新对象(内存地址改变)
其他引用	     所有引用同步清空	            其他引用仍指向旧数据
性能	        更快(直接修改原对象)	        稍慢(需创建新对象)
clear():明确表示要清空原对象内容,适用于需要保持对象身份(如多引用共享数据时)。
lst = []:创建新对象,适用于需要切断与原数据的关联。
二、以下问题解答
1. 为什么要设计 clear() 方法
保持对象身份:某些场景下需要确保对象的唯一性(如作为类属性或函数默认参数时)。

多引用同步:避免因重新赋值导致其他引用失效。

性能优化:直接清空比创建新对象更高效(尤其对大型容器)。

2. 何时用 clear(),何时用赋空
场景	                  推荐方法	   原因
需要保持原对象引用一致  	clear()	    确保所有引用同步更新(如多线程共享数据)
需要彻底释放原数据	       lst = []	    旧对象无引用时会被垃圾回收(适合内存敏感场景)
函数默认参数或类属性	   clear()	    避免因重新赋值导致默认参数失效(经典坑:def f(lst=[]):)
3. 性能对比(大型容器)
python
import timeit
# 测试列表清空
print(timeit.timeit("lst.clear()", setup="lst = list(range(1000000))"))  # ~0.005s
print(timeit.timeit("lst = []", setup="lst = list(range(1000000))"))     # ~0.008s
clear() 通常比赋空略快,但差异在小数据量时可忽略。
三、扩展知识
1. clear() 的底层实现
列表:直接重置内部数组长度(PyList_SetLength),不释放内存(可复用)。
字典/集合:移除所有哈希表条目,保留哈希表结构(避免重新哈希)。

总结
操作	             对象身份	多引用同步	性能	适用场景
container.clear()	保持	   ✔️	      更快	  共享数据、默认参数、类属性
container = 空	    新建	   ❌	     稍慢	 需要隔离旧数据或释放内存

设计哲学:clear() 的存在是为了提供一种显式且安全的清空方式,强调“修改原对象”而非“创建新对象”。
这种设计在 Python 的容器类型中保持了一致性(列表、字典、集合均支持)。
"""


"""
# 统计某个元素在列表内的数量
语法:列表.count(元素)
"""
name_list = ["lanlan", "honghong", "mingming", "honghong", "mingming"]
print(name_list.count("honghong"))# 结果为2


"""
# 统计列表中全部的元素数量
语法:len(列表)
这个不是列表的方法了,是len这个函数
"""
name_list = ["lanlan", "honghong", "mingming", "honghong", "mingming"]
print(len(name_list))# 结果为5


"""
# 切片,在后面统一介绍
"""


"""
练习:
有一个列表,内容是[21, 25, 21, 23, 22, 20],记录的是一批学生的年龄
1、定义这个列表,并用变量接收它
2、追加一个数字31,到列表的尾部
3、追加一个新列表[29, 33, 30],到列表的尾部
4、取出第一个元素(21)
5、去粗最后一个元素(30)
6、查找元素31,在列表中的下标位置
"""
age = [21, 25, 21, 23, 22, 20]
age.append(31)
print(age)
age.extend([29, 33, 30])
print(age)
print(age[0])
print(age[-1])
index = age.index(31)
print(index)
"""
结果依次为
[21, 25, 21, 23, 22, 20, 31]
[21, 25, 21, 23, 22, 20, 31, 29, 33, 30]
21
30
6
"""


/*列表的遍历*/
# 将容器内的元素依次取出进行处理的行为,称之为遍历、迭代
"""
while循环遍历列表
index = 0
while index < len(列表):
    元素 = 列表[index]
    对元素进行处理
    index += 1
"""
def list_while_func():
    name_list = ["lanlan", "honghong", "mingming", "honghong", "mingming"]

    index = 0
    while index < len(name_list):
        name = name_list[index]
        print(name)
        index += 1
"""
for循环遍历列表
for 临时变量 in 数据容器:
    处理临时变量
"""
def list_for_func():
    name_list = ["lanlan", "honghong", "mingming", "honghong", "mingming"]

    for name in (name_list):
        print(name)
# for循环更简单,while更灵活,for用于从容器内依次取出元素并处理,while适用于所有循环
"""
练习:
定义一个列表,内容是[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
遍历列表,取出列表内的偶数,并存入一个新的列表对象中
使用while循环和for循环各操作一次
提示:
通过if判断来确认偶数
通过列表的append方法来增加元素
"""
number_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
new_list = []
index = 0
while index < len(number_list):
    number = number_list[index]
    if number % 2 == 0:
        new_list.append(number)
    index += 1
print(new_list)

number_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
new_list = []
for number in number_list:
    if number % 2 == 0:
        new_list.append(number)
print(new_list)


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# tuple元组
"""
特点:
和list特点一样,唯一不同:不可修改内容,除非元组中嵌套了list,可以修改其中的list的内容
"""

"""
定义
列表可以被修改,如果想要传递的信息不想要被篡改,列表就不合适了,所以,元组一旦定义完成,就不可修改,可以理解为只读
(),每个元素之间用逗号,隔开
# 字面量
    (元素1, 元素2, 元素3, 元素4, ···)
# 定义变量
    变量名称 = (元素1, 元素2, 元素3, 元素4, ···)
# 定义空元组
    变量名称 = ()
    变量名称 = tuple()# 这种办法本质上是得到了一个元组类对象,现在还没学到面向对象,以后再展开
/* ===================================================待补充===========================================================*/
"""
(1, "hello", True)# 所以元组和列表一样,可以容纳不同数据类型的数据
t1 = (1, "hello", True)
t2 = ()
t3 = tuple()

# 注意,如果定义的元组只有一个元素,那么元素后面要加逗号(个人感觉是因为小括号本身功能比较多有关)
t4 = ("hello")
t5 = (1)
t6 = ("hello", )
t7 = (1, )
print(type(t4))# 结果为<class 'str'>
print(type(t5))# 结果为<class 'int'>
print(type(t6))# 结果为<class 'tuple'>
print(type(t7))# 结果为<class 'tuple'>

# 元组可以容纳不同类型的数据,所以当然也可以嵌套元组
t8 = ((1, 2, 3), (4, 5, 6))

# 下标索引同样适用
# num = t8(1)(2)# 语法错误,下标的用法是[]
num = t8[1][2]

"""
相关操作
"""
name_tuple = ("lanlan", "honghong", "mingming", "honghong", "mingming")
# index(): 查找某个数据,如果数据存在返回对应的下标,否则报错
index1 = name_tuple.index("honghong")# 返回的是搜索到的第一个的下标1
index2 = name_tuple.index("lanlan")# 返回0
print(index1)
print(index2)
# count(): 统计某个数据在元组中出现的次数
count = name_tuple.count("honghong")
print(count)
# len(元组): 统计元组内的元素个数
length = len(name_tuple)
print(length)
# 切片,在后面统一介绍
# 元组的遍历
index = 0
while index < len(name_tuple):
    name = name_tuple[index]
    print(name)
    index += 1

for name in name_tuple:
    print(name)
# 元组只读不可修改,尝试修改会直接报错TypeError: 'tuple' object does not support item assignment
# name_tuple[1] = "jingjing"
# 但是,但是,但是,如果元组内嵌套了一个list,list中的内容可以修改
t9 = ([1, 2, 3], "jingjing", 4, 5, 6, [7, 8, 9])
print(t9)
t9[0][1] = 13
print(t9)
# 输出结果依次为([1, 2, 3], 'jingjing', 4, 5, 6, [7, 8, 9])和([1, 13, 3], 'jingjing', 4, 5, 6, [7, 8, 9])
"""
练习:
定义一个元组,内容是("xiaoming", 11, ["football","music"]), 记录的是一个学生的信息(姓名,年龄,爱好)
请通过元组的方法,对其进行
1、查询年龄所在的下标位置
2、查询学生的姓名
3、删除学生爱好中的football
4、增加爱好coding到爱好list内
"""
student_t = ("xiaoming", 11, ["football","music"])
index = student_t.index(11)
print(index)
name = student_t[0]
print(name)
hobby_list = student_t[2]
# del hobby_list[0] 这样也可以删除
# hobby = hobby_list.pop[0] 这里报错TypeError: 'builtin_function_or_method' object is not subscriptable,因为pop是一个内置函数需要用()来包含下标
hobby = hobby_list.pop(0)# 将元组内的列表赋值给一个变量再对变量进行操作
print(student_t)
print(hobby)
hobby_list.append("coding")
print(student_t)
student_t[2].append("dancing")# 不单独将元组内的列表赋值给一个变量再对变量进行操作而是直接通过下标.append或者直接下标后接其他方法来操作也是可以的
print(student_t)
"""
以上输出依次为
1
xiaoming
('xiaoming', 11, ['music'])
football
('xiaoming', 11, ['music', 'coding'])
('xiaoming', 11, ['music', 'coding', 'dancing'])
"""


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# str字符串:
"""
字符串的特点:
只可以存储字符串
长度任意(取决于内存大小)
支持下标索引
允许重复字符串存在
不可以修改
支持while和for循环

和list不同的地方在于只能存储字符串且不可修改
"""


# 虽然字符串看上去不像容器,但是字符串也是一种容器,字符串是字符的容器,可以存放任意数量的字符

#支持下标索引
str_test = "hello world"
value1 = str_test[2]
value2 = str_test[-2]
print(value1)
print(value2)
# 字符串是无法修改的容器
str_test[2] = 'H'# 报错TypeError: 'str' object does not support item assignment


"""
# 查找特定字符串的下标索引值
语法: 字符串.index(字符串)
"""
value3 = str_test.index("world")
print(value3)# 结果为6
str_test2 = "hwllo world"
value4 = str_test2.index("w")
value5 = str_test2.index("world")
print(value4)# 结果为1
print(value5)# 结果为6,所以搜索一小段字符的索引不是以第一个字母出现的位置为准的,是搜索到准确的这一段字符,然后再看第一个字母的索引
# 一般不会搜索一个单独的字母吧,应该是搜索一个大的字符串中某个小的字符串,这种应用的场景一般是什么
"""
如下6种常见的应用场景:
1. 解析结构化文本数据
场景:从日志文件、配置文件或特定格式的文本中提取关键信息。
示例:解析 URL 中的域名
2. 验证文本格式合法性
场景:检查用户输入的字符串是否符合特定格式规则。
示例:验证电子邮件是否包含 @ 和 .
email = "user@example.com"
try:
    at_pos = email.index("@")
    dot_pos = email.index(".", at_pos)  # 从 @ 后开始查找 .
    if at_pos > 0 and dot_pos > at_pos + 1:
        print("邮箱格式有效")
except ValueError:
    print("邮箱格式无效")
3. 批量提取文本中的关键词位置
场景:在长文本中标记所有关键词出现的位置。
示例:统计文章中某个术语的所有位置
4. 实现简单文本高亮功能
场景:在命令行或日志输出中高亮显示特定词汇。
示例:将字符串中的目标词用 * 包围
5. 处理 CSV 或自定义分隔符数据
场景:解析非标准分隔符的文本行(如管道符 | 分隔)。
示例:提取管道分隔数据中的第二列
6. 构建简单编译器/解释器
场景:在编写小型 DSL(领域特定语言)时定位语法元素。
示例:解析数学表达式中的运算符位置

对比index() 与 find() 的选用
方法	         找不到时的行为	     适用场景
str.index(sub)	 抛出 ValueError	需要严格处理异常时(如格式校验)
str.find(sub)	 返回 -1	        仅检查是否存在(无需异常处理)
推荐:
如果子字符串必须存在(如解析关键数据),用 index() + try/except。
如果子字符串可能不存在(如搜索可选关键词),用 find() 判断返回值。

总结
str.index() 的核心价值在于 精确控制文本处理逻辑,尤其适合:
需要明确位置的文本解析
对输入格式有严格要求的场景
需要多次迭代查找的复杂文本操作
结合切片(如 s[start:end])和其他字符串方法(如 split()、replace()),可以高效解决大多数文本处理问题。
"""


"""
# 字符串的替换
语法: 字符串.replace(字符串1, 字符串2)
功能: 将字符串内的全部字符串1, 替换为字符串2
注意,不是修改字符串本身,而是得到了一个新的字符串
"""
name_str = ("lanlan honghong mingming honghong mingming")
print(name_str)# 结果为lanlan honghong mingming honghong mingming
name_str_new = name_str.replace("honghong", "jingjing")
print(name_str)# 结果为lanlan honghong mingming honghong mingming
print(name_str_new)# 结果为lanlan jingjing mingming jingjing mingming,所以并没有改变字符串因为字符串是不可修改的而是生成一个新的字符串


"""
# 字符串的分割
语法: 字符串.split(分隔符字符串)
功能: 按照指定的分隔符字符串,将字符串划分为多个字符串,并存入列表对象中
注意,字符串本身不变,而是得到了一个列表对象
"""
name_str = ("lanlan honghong mingming honghong mingming")
print(name_str)# 结果为lanlan honghong mingming honghong mingming
name_str_list = name_str.split(" ")
print(name_str)# 结果为lanlan honghong mingming honghong mingming
print(name_str_list)# 结果为['lanlan', 'honghong', 'mingming', 'honghong', 'mingming']
name_str_list2 = name_str.split("g")
print(name_str_list2)# 结果为['lanlan hon', 'hon', ' min', 'min', ' hon', 'hon', ' min', 'min', '']
# 所以分隔符字符串是不会再被存入的,它可以理解为就是个工具,为什么name_str_list2的结尾会有一个'',且为什么有的min和hon前面有空格,
"""
这里有的min和hon前面有空格是可以理解的,因为空格本身就是字符串的一部分
至于为什么name_str_list2的结尾会有一个'':
在 Python 中,str.split() 方法的行为是基于分隔符(这里是 "g")将字符串分割成多个部分。
当分隔符出现在字符串的末尾时,split() 会在结果的最后添加一个空字符串 '',以表示“分隔符之后的内容为空”。
"""
# 这种分割我猜一般只会用逗号空格等作为分隔符用在特定场景下


"""
# 字符串的规整操作
语法: 字符串.strip()     ================>去前后空格
语法: 字符串.strip(字符串)     ================>去前后指定字符串
这里strip可以传参也可以不传参,这是方法的重载,还没学,到时候再补充
/* ===================================================待补充===========================================================*/
"""
name_str = (" lanlan honghong mingming honghong mingming ")
print(name_str)# 结果为 lanlan honghong mingming honghong mingming (前后都有空格)
print(name_str.strip())# 结果为lanlan honghong mingming honghong mingming(前后都无空格,中间的空格并不会去掉,只是去掉前后的)
print(name_str)# 结果为 lanlan honghong mingming honghong mingming (同样是字符串本身不变,只是生成一个新的字符串)

name_str = ("12lanlan 12honghong mingming21 honghong mingming21")
print(name_str)# 结果为12lanlan 12honghong mingming21 honghong mingming21
print(name_str.strip("12"))# 结果为lanlan 12honghong mingming21 honghong mingming(前后都无1和2)
# 注意传入的事"12"就是"1"和"2"都会移除,是按照单个字符,所以字符串结尾的"21"也会移除,且中间的1和2不会去掉
print(name_str)# 结果为12lanlan 12honghong mingming21 honghong mingming21(同样是字符串本身不变,只是生成一个新的字符串)


"""
# 统计字符串中某字符串的出现次数
语法: 字符串.count(字符串)     ================>去前后指定字符串
"""
name_str = ("lanlan honghong mingming honghong mingming")
count = name_str.count("ho")
count2 = name_str.count("mingming")
print(count)# 结果为4
print(count2)# 结果为2


"""
# 统计字符串的长度
语法: len(字符串)
"""
name_str = ("lanlan honghong mingming honghong mingming")
len_name_str = len(name_str)
print(len_name_str)# 结果为42


"""
# 字符串的遍历
while和for循环遍历字符串之前已经介绍过了
"""


"""
字符串大小比较

ASCII码表,大小写英文单词、数字、特殊符号都有对应的ASCII码表值,字符串比较大小就是基于ASCII码表值进行比较的
常见的:
    0-9对应的ASCII码表值是48-57
    A-Z对应的ASCII码表值是65-90
    a-z对应的ASCII码表值是97-122

字符串比较的方式:
    按位比较,只要有一位大那么整体就大而不是对所有字母的ASCII码表值进行加和,如abcdefghijkl和ac相比,因为第二位的c比b大,所以ac要大于abcdefghijkl这一串
"""


"""
# 切片,在后面统一介绍
"""


"""
练习:
给定一个字符串"lanlan honghong mingming honghong mingming"
1、统计字符串内有多少个"ho"字符
2、将字符串内的空格都替换为"|"
3、按照"|"记性字符串分割,得到列表
"""
name_str = ("lanlan honghong mingming honghong mingming")
count = name_str.count("ho")
print(count)
name_str_new = name_str.replace(" ", "|")
print(name_str)
print(name_str_new)
name_str_new_list = name_str_new.split("|")
print(name_str_new_list)
print(name_str_new)
"""
输出依次为
4
lanlan honghong mingming honghong mingming
lanlan|honghong|mingming|honghong|mingming
['lanlan', 'honghong', 'mingming', 'honghong', 'mingming']
lanlan|honghong|mingming|honghong|mingming
"""


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 切片

"""
什么是序列: 内容连续、有序、可使用下标索引的一类数据容器,所以列表、元组、字符串都是序列
序列的切片操作: 从一个序列中,取出一个子序列
语法: 序列[起始下标:结束下标:步长]  ========>从序列中,从指定位置开始,依次取出元素,到指定位置结束,得到一个新序列(因为元组和字符串不支持修改)
起始下标表示从何处开始,可以留空,留空视作从头开始
结束下标(不含)表示从何处结束,可以留空,留空视作截取到结尾
步长表示,依次取元素的间隔
    步长1,表示一个一个取元素
    步长2,表示每次跳过一个元素取
    步长N,表示每次跳过N-1个元素取
    步长为负数表示,反向取(注意,起始下标和结束下标也要反向标记)
"""
# 对list进行切片,从1开始,到4结束,步长1
test_list = [0, 1, 2, 3, 4, 5, 6]
new_list = test_list[1:4]# 步长是1,默认是1,可以不写
print(new_list)# 结果为[1, 2, 3]
# 对tuple进行切片,从头开始,到最后结束,步长1
test_tuple = (0, 1, 2, "hello", True, 4, 5, 6)
new_tuple = test_tuple[]# 报错SyntaxError: invalid syntax,所以虽然下标可以留空,但是:必须写
new_tuple = test_tuple[:]# 结果为(0, 1, 2, 'hello', True, 4, 5, 6)
new_tuple = test_tuple[::]# 结果为(0, 1, 2, 'hello', True, 4, 5, 6)
print(new_tuple)
# 对str进行切片,从头开始,到最后结束,步长2
test_str = ("lanlan honghong mingming honghong mingming")
new_str = test_str[::2]
print(new_str)# 结果为lna ogogmnmn ogogmnmn
# 对str进行切片,从头开始,到最后结束,步长-1
test_str = ("lanlan honghong mingming honghong mingming")
new_str = test_str[::-1]
print(new_str)# 结果为gnimgnim gnohgnoh gnimgnim gnohgnoh nalnal,反过来了,以后要把什么东西全部倒序就可以用这个切片的操作
# 对list进行切片,从3开始,到1结束,步长-1
test_list = [0, 1, 2, 3, 4, 5, 6]
new_list = test_list[3:1]
print(new_list)# 结果为[]
new_list = test_list[3:1:-1]
print(new_list)# 结果为[3, 2],所以反向取必须要给出-1的步长,步长不可省略,因为步长默认是1,不因正反向而自动变成默认-1
# 对tuple进行切片,从头开始,到最后结束,步长-2
test_tuple = (0, 1, 2, "hello", True, 4, 5, 6)
new_tuple = test_tuple[::-2]# 结果为(6, 4, 'hello', 1)
print(new_tuple)
"""
练习:
字符串"万过薪月 ,员序程马黑来 ,nohtyP学"
请使用学过的任何方式,得到"黑马程序员"
1、先倒序再切片
2、先切片再倒序
3、split分隔", "replace替换"来"为空,倒序字符串,注意这里是用逗号和空格作为分隔符的,不是只用逗号   =====>这个方法是因为题目本身是字符串,用的是字符串的方法
"""
str = ("学Python, 来黑马程序员, 月薪过万")
new_str = str[::-1]
print(new_str)

str = ("万过薪月 ,员序程马黑来 ,nohtyP学")
new_str = str[10:6:-1]# 得到黑马程序,因为是不含结束下标的,所以应该是new_str = str[10:5:-1],这是倒序切片取出
print(new_str)
new_str = str[::-1]# 先倒序
final_str = new_str[10:15]# 再切片取出
print(final_str)# 结果为黑马程序员

str = ("万过薪月, 员序程马黑来, nohtyP学")
str_list = str.split(",")# 得到的应该是["万过薪月", " 员序程马黑来", " nohtyP学"]
# 我这里只用了逗号所以分隔后还是很麻烦     ==============>老师的意思是逗号和空格一起作为分隔符,666
print(str_list)# ['万过薪月 ', '员序程马黑来 ', 'nohtyP学']
str_str = str_list[1]# 得到的应该是" 员序程马黑来"
print(str_str)
str_rep = str_str.replace("来", "")
print(str_rep)# 得到" 员序程马黑"
# 还不如直接去掉前后的空格和来
str_strip = str_str.strip("来 ")
print(str_strip)# 得到了"员序程马黑",再倒序就可以了
final_str = str_strip[::-1]
print(final_str)# 得到了"黑马程序员"

# 老师的方法
my_str = ("万过薪月, 员序程马黑来, nohtyP学")
result = my_str[::-1][9:14]# 倒序切片取出
result = my_str[5:10][::-1]# 切片取出倒序
result = my_str.split(", ")[1].replace("来", "")[::-1]# 逗号空格分隔,然后取列表[1]个元素,然后替换,然后倒序=============>直接一行取出,666


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# set集合

"""
集合的特点:
可以容纳多个数据
可以容纳不同类型的数据
数据无序,所以不支持下标索引,所以不支持while循环
    注意每次运行集合中元素的顺序都会改变,因为集合是无序的,那集合在内存中是如何存储的,又是如何被调用出来的呢
    序列是连续的,它们在内存中是取出一块连续的内存用于存储,所以是有顺序的
    集合是无序的,每个元素的存储位置由哈希确定,关于哈希之后再补充
    /* ===================================================待补充=======================================================*/
不允许数据重复
可修改
只支持for循环

和list的区别: 无序、数据不可重复、只支持for循环
"""


"""
集合的定义
前面三个序列容器都是有序且能容纳可重复数据的,但是如果要容纳不可重复数据怎么办呢,集合内部数据不可重复且无序
所以集合,自带去重功能
从deepseek查的集合的使用场景感觉更多的是用于计算和验证两个集合是否用重复项等,好像没前面三个序列容器使用广泛了
{}, 每个元素之间用逗号,隔开
# 字面量
    {元素1, 元素2, 元素3, 元素4, ···}
# 定义变量
    变量名称 = {元素1, 元素2, 元素3, 元素4, ···}
# 定义空集合
    变量名称 = set()
    注意没有变量名称 = {}这种方法
"""
test_set = {"lanlan", "honghong", "mingming", "honghong", "mingming"}# 这样不可以吧,集合内元素不可重复
empty_set = set()
print(test_set)# 直接得到{'lanlan', 'honghong', 'mingming'},可见即便定义的时候包含了重复内容,也会默认将重复内容去重
print(test_set)# 再次运行得到{'lanlan', 'mingming', 'honghong'},元素顺序改变,说明集合是无序的
print(empty_set)# 得到set()    ============>这是为什么,因为一个空的{}表示的事一个空集合,所以空集合只能用set()来表示
print(type(test_set))# 得到的是<class 'set'>
print(type(empty_set))# 得到的是<class 'set'>


# 集合的常见操作
"""
添加新元素
语法: 集合.add(元素), 将指定元素添加到集合内
结果: 集合本身被修改,添加了新元素
"""
test_set = {'lanlan', 'mingming', 'honghong'}
print(test_set)# 得到{'honghong', 'lanlan', 'mingming'}
test_set.add("jingjing")
print(test_set)# 得到{'honghong', 'lanlan', 'jingjing', 'mingming'}
test_set.add("honghong")
print(test_set)# 得到{'honghong', 'lanlan', 'jingjing', 'mingming'},并没有加入一个重复元素


"""
移除元素
语法: 集合.remove(元素), 将指定元素从集合内移除
结果: 集合本身被修改,移除了元素
"""
test_set = {'lanlan', 'mingming', 'honghong'}
print(test_set)# 得到{'honghong', 'lanlan', 'mingming'}
test_set.remove("honghong")
print(test_set)# 得到{'mingming', 'lanlan'}


"""
随机取出一个元素
语法: 集合.pop(), 从集合中随机取出一个元素
结果: 会得到一个元素的结果,同时集合本身被修改,元素被移除   ===========>注意这里也会移除,和remove的区别是指定移除
为什么会有这样的功能,适用场景是什么,举例如下,主要是侧重随机性: 
1、随机抽样与抽奖系统
participants = {"Alice", "Bob", "Charlie", "Diana"}
winner = participants.pop()  # 随机选出一位获奖者
print(f"获奖者是: {winner}")
2、任务分配与负载均衡
# 从可用工作节点集合中随机分配任务
available_workers = {"worker1", "worker2", "worker3", "worker4"}
task_assignment = available_workers.pop()
3、游戏开发
# 从牌堆中随机抽牌
card_deck = {"A♠", "K♥", "Q♦", "J♣", "10♠"}  # 简化的牌组
drawn_card = card_deck.pop()
4、算法实现(如Prim最小生成树算法)
# 简化版的Prim算法示例
unvisited = {"A", "B", "C", "D"}
start_node = unvisited.pop()  # 随机选择一个起始节点
5、资源管理
# 从可用资源池中随机分配资源
available_ports = {8000, 8001, 8002, 8003}
assigned_port = available_ports.pop()
"""
test_set = {'lanlan', 'mingming', 'honghong'}
print(test_set)# 得到{'honghong', 'lanlan', 'mingming'}
element = test_set.pop()
print(test_set, element)# 每次结果都不一样, 不过剩下的test_set和element肯定是存在对应关系的
print(type(element))# 结果为<class 'str'>


"""
清空集合
语法: 集合.clear()
"""
test_set = {'lanlan', 'mingming', 'honghong'}
test_set.clear()
print(test_set)# 得到set()


"""
取两个集合的差集
语法: 集合1.difference(集合2), 取出集合1和集合2的差集(集合1有而集合2没有的)
结果: 得到一个新集合, 集合1和集合2不变
"""
test_set1 = {'lanlan', 'mingming', 'honghong'}
test_set2 = {'lanlan', 'honghong'}
difference_set = test_set1.difference(test_set2)
print(difference_set)# 得到{'mingming'}
print(test_set1)
print(test_set2)


"""
消除两个集合的差集
语法: 集合1.difference_update(集合2), 对比集合1和集合2,在集合1内,删除和集合2相同的元素
结果: 集合1被修改,集合2不变
"""
test_set1 = {'lanlan', 'mingming', 'honghong'}
test_set2 = {'lanlan'}
difference_set = test_set1.difference_update(test_set2)
print(difference_set)# 得到None   =============>difference_update这个方法没有返回值
print(test_set1)# 得到{'mingming', 'honghong'},集合1删除了'lanlan'
print(test_set2)# 得到{'lanlan'},集合2不变


"""
两个集合合并为1个
语法: 集合1.union(集合2), 将集合1和集合2组合成新集合
结果: 得到一个新集合, 集合1和集合2不变
"""
test_set1 = {'lanlan', 'mingming', 'honghong'}
test_set2 = {'lanlan','jingjing'}
union_set = test_set1.union(test_set2)
print(union_set)# 得到{'honghong', 'lanlan', 'mingming', 'jingjing'}, 'lanlan'去重只保留一个
print(test_set1)# 得到{'honghong', 'lanlan', 'mingming'},集合1不变
print(test_set2)# 得到{'lanlan','jingjing'},集合2不变


"""
统计集合元素数量
语法: len(集合)
"""
test_set1 = {'lanlan', 'mingming', 'honghong'}
length = len(test_set1)
print(length)# 3


"""
集合的遍历
只能用for循环
"""
test_set1 = {'lanlan', 'mingming', 'honghong'}
for name in test_set1:
    print(name)


"""
练习:
有如下列表对象:
name_list = ["lanlan", "honghong", "mingming", "honghong", "mingming", "jingjing"]
定义一个空集合
通过for循环遍历列表
在for循环中将列表的元素添加至集合
最终得到元素去重后的集合对象,并打印输出
"""
name_list = ["lanlan", "honghong", "mingming", "honghong", "mingming", "jingjing"]
name_set = set()
for name in name_list:
    print(name)
    name_set.add(name)
print(name_set)# 得到{'honghong', 'mingming', 'lanlan', 'jingjing'}

# 如果像下面这样更能体现集合的去重性质
name_list = ["lanlan", "honghong", "mingming", "honghong", "mingming", "jingjing"]
name_set = set()
for name in name_list:
    print(name)
    name_set.add(name)
    print(name_set)
"""
输出依次为:
lanlan
{'lanlan'}
honghong
{'honghong', 'lanlan'}
mingming
{'mingming', 'honghong', 'lanlan'}
honghong
{'mingming', 'honghong', 'lanlan'}
mingming
{'mingming', 'honghong', 'lanlan'}
jingjing
{'mingming', 'honghong', 'lanlan', 'jingjing'}
"""


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# dict字典/映射

# 字典的特点
"""
可以容纳多个数据
可以容纳不同类型的数据
数据无序,所以不支持下标索引,所以不支持while循环
不允许key重复,重复会覆盖value值
可修改
只支持for循环

和list的区别: 无序、key不可重复、只支持for循环
和集合的区别,元素是key和value的键值对,可以通过key获得value,其他都一样
# 字典和集合可以理解为一类,前面3种序列理解为一类,还是很好记的
"""


# 字典的定义
"""
为什么要使用字典: 生活中的字典是通过字找到字对应的含义,python中的字典是通过key找到对应的value
比如老师有一份名单记录了同学们的考试成绩,可以通过学生姓名找到学生的成绩,通过字典最合适
{}, 每个元素之间用逗号,隔开, 元素是一个个键值对
# 字面量
    {key:value, key:value, key:value, key:value, ···}      =============> key:value 这个小整体才是一个元素
# 定义变量
    变量名称 = {key:value, key:value, key:value, key:value, ···}
# 定义空字典
    变量名称 = {}    ===============>空集合不支持这样定义,所以这样定义不是定义了一个空集合,而是定义了一个空字典
    变量名称 = dict()

字典不允许key重复,就像现实生活中的字典不允许字重合和集合不允许数据重复,很好理解,如果要根据key查找对应的value那么key重复了哪个value才是要查找的value呢
key和value可以是任意数据类型,但key不可为字典,value的数据类型不受限,所以字典是可以嵌套的
这几种数据类型谁可以嵌套谁不可以嵌套为什么 =============>见最下方
/* ===================================================已补充===========================================================*/
"""
{"honghong":99, "jingjing":98, "mingming":97}
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
print(type(score_dict))# <class 'dict'>
score_dict_empty = {}
score_dict_empty = dict()
# 定义重复key的字典
score_dict = {"honghong":99, "jingjing":98, "mingming":97, "honghong":96}
print(score_dict)# 得到{'honghong': 96, 'jingjing': 98, 'mingming': 97}  ==========>   注意honghong的成绩被后面出现的键值对覆盖了,相当于新值覆盖旧值
# 从字典中基于key获取value   =============>字典和集合一样不可以用下标索引,所以只能通过key来获取对应的value了
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
print(score_dict["honghong"])# 得到99,使用方式和下标索引一样,是用[]来包含key
# 定义嵌套字典   ===========>可以这样理解,一个学生有多个科目的成绩都需要记录
"""
score_dict = {{"honghong":99, "jingjing":98, "mingming":97}, {"honghong":89, "jingjing":88, "mingming":87}, {"honghong":79, "jingjing":78, "mingming":77}}
#不是像上面这样嵌套的哈哈哈哈,而是下面这样
"""
score_dict = {
    "honghong":{
        "语文":99,
        "数学":89,
        "英语":79
    }, 
    "jingjing":{
        "语文":98,
        "数学":88,
        "英语":78
    }, 
    "mingming":{
        "语文":97,
        "数学":87,
        "英语":77
    }
}
# 从嵌套字典中获取数据
score = score_dict["honghong"]["英语"]
print(score)# 得到79


# 字典的常用操作
"""
新增元素和修改元素
语法: 字典[key] = value, 结果: 字典被修改, 修改了元素   ======>如果key之前不在字典里就是新增,如果key之前已经在字典里,这个语法就会把key对应的value值更新
"""
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
score_dict["lanlan"] = 66
print(score_dict)# 得到{'honghong': 99, 'jingjing': 98, 'mingming': 97, 'lanlan': 66}新增了lanlan的成绩
score_dict["mingming"] = 55
print(score_dict)# 得到{'honghong': 99, 'jingjing': 98, 'mingming': 55, 'lanlan': 66}更新了mingming的成绩


"""
删除元素
语法: 字典.pop(key), 结果: 获得指定key的value,同时字典被修改,指定key的数据被删除
"""
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
score = score_dict.pop("honghong")
print(score)# 得到99
print(score_dict)# 得到{'jingjing': 98, 'mingming': 97}


"""
清空元素
语法: 字典.clear(), 结果: 字典被修改,元素被清空
"""
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
score_dict.clear()
print(score_dict)# 得到{}



"""
获取全部的key
语法: 字典.keys(), 结果: 得到字典中全部的key
"""
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
keys = score_dict.keys()
print(score_dict)# 得到{'honghong': 99, 'jingjing': 98, 'mingming': 97},说明keys这个操作不会对原有的字典有任何改动
print(keys)# 得到dict_keys(['honghong', 'jingjing', 'mingming'])这是个元组,元组里只包含了一个元素是一个列表,但是这个元素后面又没有逗号,那就不是元祖,是列表吗
print(type[keys])# 得到type[dict_keys(['honghong', 'jingjing', 'mingming'])]不理解
# 这里打错了,应该用print(type(keys))就不会有那么多疑问了
print(type(keys))# 得到<class 'dict_keys'>
"""
1. dict_keys 对象的本质
当你调用 score_dict.keys() 时,返回的是一个 dict_keys 视图对象,而不是元组(tuple)或列表。这是 Python 3 中专门设计的高效字典视图类型。
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
keys = score_dict.keys()
print(keys)  # 输出: dict_keys(['honghong', 'jingjing', 'mingming'])
print(type(keys))  # 正确写法:输出 <class 'dict_keys'>
2. 关键特性
特性	        说明
动态视图    	会实时反映字典的修改(与字典同步更新)
不可索引	    不能直接通过 keys[0] 访问(需先转为列表或元组)
内存高效	    不复制数据,只是对字典键的引用
支持集合操作	可以进行交集(&)、并集(`	`)等操作
4. 为什么设计 dict_keys 类型
Python 3 用这种设计是为了:
性能优化:避免每次调用 .keys() 都复制数据。
动态同步:当字典修改时,视图会自动更新。
score_dict["new"] = 100
print(keys)  # 输出会包含 "new"
内存节省:对于大型字典,直接操作视图比生成列表更高效。
5. 实际使用建议
需要索引访问时:显式转换为列表或元组
key_list = list(score_dict.keys())
print(key_list[0])  # 输出: "honghong"
需要判断键是否存在:直接使用视图(无需转换)
if "honghong" in keys:  # 高效操作
    print("存在")
需要集合操作时:
other_keys = {"jingjing", "xiaoming"}
print(keys & other_keys)  # 输出: {"jingjing"}
"""


"""
遍历字典
方式1: 通过上面拿到的全部的key就可以遍历了
方式2: 直接对字典进行for循环
"""
# 方式1
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
keys = score_dict.keys()
for key in keys:
    print(key)
    print(score_dict[key])
"""
输出为:
honghong
99
jingjing
98
mingming
97
"""
# 方式2 输出和方式1是一样的
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
for key in score_dict:
    print(key)
    print(score_dict[key])


"""
统计字典内的元素数量
语法: len(字典)
"""
score_dict = {"honghong":99, "jingjing":98, "mingming":97}
length = len(score_dict)
print(length)# 得到3


"""
练习:升职加薪
有如下员工信息,请使用字典完成数据记录,并通过for循环,对所有级别为1的员工:级别上升一级、薪水增加1000元,输出改变前后全部员工信息
"""
employees_info = {
    "莹莹":{
        "部门":"科技部",
        "工资":3000,
        "级别":1
    },
    "静静":{
        "部门":"市场部",
        "工资":5000,
        "级别":2
    },
    "玲玲":{
        "部门":"市场部",
        "工资":7000,
        "级别":3
    },
    "冰冰":{
        "部门":"科技部",
        "工资":4000,
        "级别":1
    },
    "青青":{
        "部门":"市场部",
        "工资":6000,
        "级别":2
    }
}
print(f"全体员工当前信息如下:{employees_info}")
for key in employees_info:
    if employees_info[key]["级别"] == 1:
        employees_info[key]["级别"] += 1
        employees_info[key]["工资"] += 1000
print(f"级别为1的员工完成升职加薪后,全体员工信息如下:{employees_info}")
"""
输出为(为了显示手动换行了)
全体员工当前信息如下:{
'莹莹': {'部门': '科技部', '工资': 3000, '级别': 1}, 
'静静': {'部门': '市场部', '工资': 5000, '级别': 2}, 
'玲玲': {'部门': '市场部', '工资': 7000, '级别': 3}, 
'冰冰': {'部门': '科技部', '工资': 4000, '级别': 1}, 
'青青': {'部门': '市场部', '工资': 6000, '级别': 2}
}
级别为1的员工完成升职加薪后,全体员工信息如下:{
'莹莹': {'部门': '科技部', '工资': 4000, '级别': 2}, 
'静静': {'部门': '市场部', '工资': 5000, '级别': 2}, 
'玲玲': {'部门': '市场部', '工资': 7000, '级别': 3}, 
'冰冰': {'部门': '科技部', '工资': 5000, '级别': 2}, 
'青青': {'部门': '市场部', '工资': 6000, '级别': 2}
}
"""


/*-----------------------------------------------------------------------------------------------------------------------------------------------*/
# 数据容器的通用操作

#都支持遍历,集合和字典只支持for循环遍历

#都支持len()、max()、min()  ==========>求元素数量、求最大元素、求最小元素
test_list = [1, 2, 3, 4, 5]
test_tuple = (1, 2, 3, 4, 5)
test_str = "abcdefg"
test_set = {1, 2, 3, 4, 5}
test_dict = {"key1":1, "key2":2, "key3":3, "key4":4, "key5":5}
print(f"list的长度是:{len(test_list)}")
print(f"tuple的长度是:{len(test_tuple)}")
print(f"str的长度是:{len(test_str)}")
print(f"set的长度是:{len(test_set)}")
print(f"dict的长度是:{len(test_dict)}")
"""
输出为
list的长度是:5
tuple的长度是:5
str的长度是:7
set的长度是:5
dict的长度是:5
"""
print(f"list的最大元素是:{max(test_list)}")
print(f"tuple的最大元素是:{max(test_tuple)}")
print(f"str的最大元素是:{max(test_str)}")
print(f"set的最大元素是:{max(test_set)}")
print(f"dict的最大元素是:{max(test_dict)}")
"""
输出为
list的最大元素是:5
tuple的最大元素是:5
str的最大元素是:g
set的最大元素是:5
dict的最大元素是:key5
其中str和dict的最大好像不太好理解,str的比较是比较的字母,dict的最大没有管key对应的value的值直接比较key,而几个key都是字符串,是按字符串大小进行比较的
"""
print(f"list的最小元素是:{min(test_list)}")
print(f"tuple的最小元素是:{min(test_tuple)}")
print(f"str的最小元素是:{min(test_str)}")
print(f"set的最小元素是:{min(test_set)}")
print(f"dict的最小元素是:{min(test_dict)}")
"""
输出为
list的最小元素是:1
tuple的最小元素是:1
str的最小元素是:a
set的最小元素是:1
dict的最小元素是:key1
"""

# 通用转换功能
"""
list(容器): 将容器转换为列表
tuple(容器): 将容器转换为元组
str(容器): 将容器转换为字符串
set(容器): 将容器转换为集合
因为没办法凭空变出value值,所以list等容器类型是没法转成字典的
"""
test_list = [1, 2, 3, 4, 5]
test_tuple = (1, 2, 3, 4, 5)
test_str = "abcdefg"
test_set = {1, 2, 3, 4, 5}
test_dict = {"key1":1, "key2":2, "key3":3, "key4":4, "key5":5}
print(f"list转列表为{list(test_list)}")
print(f"tuple转列表为{list(test_tuple)}")
print(f"str转列表为{list(test_str)}")
print(f"set转列表为{list(test_set)}")
print(f"dict转列表为{list(test_dict)}")
"""
输出为
list转列表为[1, 2, 3, 4, 5]                                ============>符号更改
tuple转列表为[1, 2, 3, 4, 5]                               ============>符号更改
str转列表为['a', 'b', 'c', 'd', 'e', 'f', 'g']             ============>每个元素都取出来作为一个元素组成列表
set转列表为[1, 2, 3, 4, 5]                                 ============>符号更改
dict转列表为['key1', 'key2', 'key3', 'key4', 'key5']       ============>只保留了key,value去掉,每个key作为一个元素
"""
print(f"list转元组为{tuple(test_list)}")
print(f"tuple转元组为{tuple(test_tuple)}")
print(f"str转元组为{tuple(test_str)}")
print(f"set转元组为{tuple(test_set)}")
print(f"dict转元组为{tuple(test_dict)}")
"""
输出为        ==================>大致规律和转list一样
list转元组为(1, 2, 3, 4, 5)
tuple转元组为(1, 2, 3, 4, 5)
str转元组为('a', 'b', 'c', 'd', 'e', 'f', 'g')
set转元组为(1, 2, 3, 4, 5)
dict转元组为('key1', 'key2', 'key3', 'key4', 'key5')
"""
print(f"list转字符串为{str(test_list)}")
print(f"tuple转字符串为{str(test_tuple)}")
print(f"str转字符串为{str(test_str)}")
print(f"set转字符串为{str(test_set)}")
print(f"dict转字符串为{str(test_dict)}")
"""
输出为        ==================>看上去没有变化,但其实两侧都有双引号""
list转字符串为[1, 2, 3, 4, 5]                                                ============>"[1, 2, 3, 4, 5] "
tuple转字符串为(1, 2, 3, 4, 5)                                               ============>"(1, 2, 3, 4, 5) "
str转字符串为abcdefg                                                         ============>"abcdefg"
set转字符串为{1, 2, 3, 4, 5}                                                 ============>"{1, 2, 3, 4, 5}"
dict转字符串为{'key1': 1, 'key2': 2, 'key3': 3, 'key4': 4, 'key5': 5}        ============>"{'key1': 1, 'key2': 2, 'key3': 3, 'key4': 4, 'key5': 5}"
                                                                                         字典转str保留了value
"""
print(f"list转集合为{set(test_list)}")
print(f"tuple转集合为{set(test_tuple)}")
print(f"str转集合为{set(test_str)}")
print(f"set转集合为{set(test_set)}")
print(f"dict转集合为{set(test_dict)}")
"""
输出为        ==================>大致规律和转list一样
list转集合为{1, 2, 3, 4, 5}
tuple转集合为{1, 2, 3, 4, 5}
str转集合为{'a', 'f', 'c', 'e', 'b', 'd', 'g'}
set转集合为{1, 2, 3, 4, 5}
dict转集合为{'key3', 'key4', 'key2', 'key1', 'key5'}
"""


# sorted排序: sorted(容器,[reverse=True]), 将容器进行排序
test_list = [1, 6, 3, 8, 5]
test_tuple = (1, 6, 3, 8, 5)
test_str = "ajckeog"
test_set = {1, 6, 3, 8, 5}
test_dict = {"key1":1, "key6":6, "key3":3, "key8":8, "key5":5}
print(f"list排序为{sorted(test_list)}")
print(f"tuple排序为{sorted(test_tuple)}")
print(f"str排序为{sorted(test_str)}")
print(f"set排序为{sorted(test_set)}")
print(f"dict排序为{sorted(test_dict)}")
print(f"list排序后是否改变原容器{test_list}")
print(f"tuple排序后是否改变原容器{test_tuple}")
print(f"str排序后是否改变原容器{test_str}")
print(f"set排序后是否改变原容器{test_set}")
print(f"dict排序后是否改变原容器{test_dict}")
"""
输出为                                       ===================>默认升序排序,且排序之后都变成了list类型,盲猜这是因为元组和str类型是不可修改的
                                                                而集合和dict是无序的,所以排序后将元素放到list类型的一个新变量里
list排序为[1, 3, 5, 6, 8]
tuple排序为[1, 3, 5, 6, 8]
str排序为['a', 'c', 'e', 'g', 'j', 'k', 'o']
set排序为[1, 3, 5, 6, 8]
dict排序为['key1', 'key3', 'key5', 'key6', 'key8']
list排序后是否改变原容器[1, 6, 3, 8, 5]
tuple排序后是否改变原容器(1, 6, 3, 8, 5)
str排序后是否改变原容器ajckeog
set排序后是否改变原容器{1, 3, 5, 6, 8}
dict排序后是否改变原容器{'key1': 1, 'key6': 6, 'key3': 3, 'key8': 8, 'key5': 5}
"""
print(f"list倒序排序为{sorted(test_list, reverse=True)}")
print(f"tuple倒序排序为{sorted(test_tuple, reverse=True)}")
print(f"str倒序排序为{sorted(test_str, reverse=True)}")
print(f"set倒序排序为{sorted(test_set, reverse=True)}")
print(f"dict倒序排序为{sorted(test_dict, reverse=True)}")
"""
输出为                                                  ===================>reverse是反转的意思,reverse=True变成降序排序
list倒序排序为[8, 6, 5, 3, 1]
tuple倒序排序为[8, 6, 5, 3, 1]
str倒序排序为['o', 'k', 'j', 'g', 'e', 'c', 'a']
set倒序排序为[8, 6, 5, 3, 1]
dict倒序排序为['key8', 'key6', 'key5', 'key3', 'key1']
"""


# 补充列表的排序方法======>可以指定排序规则
"""
列表.sort(key=选择排序依据的函数, reverse = True|False)
    参数key: 要求传入一个函数, 表示将列表的每一个元素都传入函数中, 返回排序的依据
    参数reverse: 是否反转排序结果, True表示降序, False表示升序
使用案例见01-10-11-12_数据可视化的GDP动态柱状图绘制
见bar_pyecharts_practice.py
"""


# 这几种数据类型谁可以嵌套谁不可以嵌套为什么
"""
在 Python 中,数据类型的嵌套能力主要取决于它们的 **可变性** 和 **哈希性**。以下是详细的分类和原理解释:

---

### **一、可以嵌套的数据类型**
#### 1. **列表(`list`)**
   - **可嵌套**:列表可以包含任何其他数据类型(包括自身)。
   - **示例**:
     ```python
     nested_list = [1, ["a", "b"], {"key": "value"}]
     ```
   - **原因**:列表是**可变但非哈希**的,Python 不限制其元素类型。

#### 2. **元组(`tuple`)**
   - **可嵌套**:元组可以包含任何类型(包括可变类型如列表)。
   - **示例**:
     ```python
     nested_tuple = (1, [2, 3], {"name": "Alice"})
     ```
   - **限制**:虽然元组本身不可变,但它可以包含可变元素(此时元组**不再是哈希的**)。

#### 3. **字典(`dict`)**
   - **可嵌套**:字典的**值**可以是任意类型,但**键**必须是不可变类型(如 `str`, `int`, `tuple`)。
   - **示例**:
     ```python
     nested_dict = {"key1": [1, 2], "key2": {"subkey": 3}}
     ```

#### 4. **集合(`set`)**
   - **可嵌套值**:集合的元素必须是**不可变类型**(如 `int`, `str`, `tuple`),但集合本身不能嵌套集合(因为集合是可变类型)。
   - **示例**:
     ```python
     valid_set = {1, 2, ("a", "b")}  # 合法
     invalid_set = {1, {2, 3}}       # 报错:TypeError
     ```

---

### **二、不可嵌套的数据类型**
#### 1. **集合(`set`)和冻结集合(`frozenset`)**
   - **不可嵌套可变类型**:集合的元素必须是**可哈希的**(即不可变的),因此不能包含列表、字典或其他集合。
   - **特殊案例**:
     ```python
     # 冻结集合(frozenset)可以作为字典的键或集合的元素
     fs = frozenset([1, 2])
     valid_dict = {fs: "value"}  # 合法
     ```

#### 2. **字典的键(`dict` keys)**
   - **必须不可变**:字典的键不能是列表、字典或集合等可变类型。
   - **示例**:
     ```python
     valid_key = {("tuple", "key"): 1}  # 合法
     invalid_key = {["list", "key"]: 1} # 报错:TypeError
     ```

---

### **三、嵌套限制的原理**
#### 1. **哈希性(Hashability)**
   - Python 要求字典的键和集合的元素必须是**可哈希的**(即不可变的)。
   - 如果对象在生命周期内可能改变(如列表),其哈希值也会变,导致哈希表(字典/集合内部实现)混乱。

#### 2. **可变性(Mutability)**
   - **可变类型**(如 `list`, `dict`, `set`)不能作为字典键或集合元素,但可以作为其他容器的值。
   - **不可变类型**(如 `int`, `str`, `tuple`)可以自由嵌套。

#### 3. **递归引用问题**
   - Python 允许**自引用嵌套**(如列表包含自身),但实际使用需谨慎:
     ```python
     lst = [1, 2]
     lst.append(lst)  # 合法,但打印时显示 [...]
     ```

---

### **四、常见嵌套场景示例**
#### 1. **多层数据结构**
   ```python
   # 字典嵌套列表
   data = {
       "users": ["Alice", "Bob"],
       "scores": {"Alice": 90, "Bob": 85}
   }
   ```

#### 2. **不可变结构的嵌套**
   ```python
   # 元组嵌套冻结集合
   config = (frozenset({"auto_save", "backup"}), "/path/to/file")
   ```

#### 3. **非法嵌套(运行时报错)**
   ```python
   # 尝试将列表作为集合元素
   invalid = {1, 2, [3, 4]}  # TypeError: unhashable type: 'list'
   ```

---

### **五、总结表格**
| 数据类型       | 是否可嵌套其他类型 | 是否可被嵌套(作为元素/键) | 限制条件                     |
|----------------|--------------------|----------------------------|-----------------------------|
| **列表(`list`)** | ✔️ 任意类型        | ✔️ 可被嵌套                | 无                          |
| **元组(`tuple`)**| ✔️ 任意类型        | ✔️ 可被嵌套                | 若含可变元素,则不可哈希     |
| **字典(`dict`)**| ✔️ 值任意,键需不可变 | ✔️ 可被嵌套(仅作为值)    | 键必须是不可变类型           |
| **集合(`set`)** | ❌ 元素需不可变    | ❌ 不可被嵌套              | 元素必须是可哈希的           |
| **冻结集合(`frozenset`)** | ❌ 元素需不可变 | ✔️ 可被嵌套                | 同集合的元素限制             |

---

### **六、设计哲学**
Python 对嵌套的限制基于以下原则:
1. **安全性**:防止可变对象作为键时因修改导致哈希表失效。
2. **一致性**:不可变对象(如 `tuple`)可以安全地用作字典键。
3. **灵活性**:允许复杂数据结构(如列表嵌套字典)以满足实际需求。

理解这些规则后,你可以更高效地设计数据结构,避免常见的 `TypeError` 错误。
"""
